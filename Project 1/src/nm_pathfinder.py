import mathfrom queue import PriorityQueuedef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    # Keep track of the starting and ending boxes    starting_box = None    ending_box = None    # keep track of point history    boxLocationHistory = dict()    # Step 1: Find the boxes that we start and end in    for box in mesh["boxes"]:        # Check the starting point        if checkPointInBox(source_point, box):            starting_box = box            boxLocationHistory[box] = source_point        # Check the ending point        if checkPointInBox(destination_point, box):            ending_box = box            boxLocationHistory[box] = destination_point    print("\nDEBUG: Starting Box:" + str(starting_box) + " contains starting point " + str(source_point))    print("DEBUG: Ending Box:" + str(ending_box) + " contains ending point " + str(destination_point))    # Step 2: pathfind between those boxes    if starting_box is not None and ending_box is not None:        foundPath = aStarAlgo(boxLocationHistory, starting_box, ending_box, mesh)        if foundPath is False:            print("No path Possible!")            return path, boxes.keys()        for box in foundPath:            boxes[box] = "path"    else:        print("No path possible!")        return path, boxes.keys()    # Step 3: draw a path    for index, box in enumerate(boxes.keys()):        # Deal with the start point        if box == starting_box:            path.append(source_point)            continue        # Now calculate stuff - box is the next box and the last can be found with foundPath[i-1]        print("DEBUG: Current Box: " + str(box))        print("DEBUG: Last Box: " + str(foundPath[index - 1]))        newPoint = getPathBetweenBoxes(path[index - 1], foundPath[index - 1], box)        path.append(newPoint)    path.append(destination_point)    return path, boxes.keys()def checkPointInBox(point, box):    # point is defined as (y,x) for some reason    # Box is defined as (y1, y2, x1, x2) even though the instructions say it is the other way    if box[0] <= point[0] <= box[1] and box[2] <= point[1] <= box[3]:        return True    return Falsedef aStarAlgo(boxLocationHistory, startingBox, endingBox, grid):    frontier = PriorityQueue()    frontier.put((0, startingBox))    came_from = dict()    cost_so_far = dict()    came_from[startingBox] = None    cost_so_far[startingBox] = 0    while not frontier.empty():        current_priority, current = frontier.get()        if current == endingBox:            break        for next in grid["adj"][current]:            # Get the extra cost for this particular box            new_cost = cost_so_far[current] + calculateTraversalCost(current, next, boxLocationHistory, endingBox)            if next not in cost_so_far or new_cost < cost_so_far[next]:                cost_so_far[next] = new_cost                priority = new_cost + calculateDistance(boxLocationHistory[next], boxLocationHistory[endingBox])                frontier.put((priority, next))                came_from[next] = current    # now go through and get a list we can work with    path = []    current = endingBox    while current is not None:        path.append(current)        current = came_from[current]    path.reverse()    return pathdef calculateTraversalCost(startBox, destBox, pointLibrary, finalBox):    if destBox == finalBox:        return calculateDistance(pointLibrary[startBox], pointLibrary[finalBox])    if destBox not in pointLibrary:        pointLibrary[destBox] = getPathBetweenBoxes(pointLibrary[startBox], startBox, destBox)    return calculateDistance(pointLibrary[startBox], pointLibrary[destBox])def calculateDistance(point1, point2):    return math.sqrt(pow((point1[0] - point2[0]), 2) + pow((point1[1] - point2[1]), 2))def getPathBetweenBoxes(currentPoint, box1, box2):    # Calculate intersection bounds    intersect_min_x = max(box1[2], box2[2])    intersect_max_x = min(box1[3], box2[3])    intersect_min_y = max(box1[0], box2[0])    intersect_max_y = min(box1[1], box2[1])    # Clamp point to intersection bounds    clamped_x = max(intersect_min_x, min(currentPoint[1], intersect_max_x))    clamped_y = max(intersect_min_y, min(currentPoint[0], intersect_max_y))    return clamped_y, clamped_x