import mathfrom queue import Queuefrom math import inf, sqrtfrom heapq import heappop, heappushdef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    # Keep track of the starting and ending boxes    starting_box = None    ending_box = None    # Step 1: Find the boxes that we start and end in    for box in mesh["boxes"]:        # Check the starting point        if checkPointInBox(source_point, box):            starting_box = box        # Check the ending point        if checkPointInBox(destination_point, box):            ending_box = box    print("\nDEBUG: Starting Box:" + str(starting_box) + " contains starting point " + str(source_point))    print("DEBUG: Ending Box:" + str(ending_box) + " contains ending point " + str(destination_point))    # step 2: pathfind between those boxes    if starting_box is not None and ending_box is not None:        foundPath = dijkstraAlg(source_point, destination_point, starting_box, ending_box, mesh)        if foundPath is False:            print("No path Possible!")            return path,boxes.keys()        for box in foundPath:            boxes[box] = "path"    else:        print("No path possible!")        return path, boxes.keys()    # Step 3: draw a path    for index, box in enumerate(boxes.keys()):        # Deal with the start point        if box == starting_box:            path.append(source_point)            continue        # Now calculate stuff - box is the next box and the last can be found with foundPath[i-1]        print("DEBUG: Current Box: " + str(box))        print("DEBUG: Last Box: " + str(foundPath[index - 1]))        newPoint = getPathBetweenBoxes(path[index - 1], foundPath[index - 1], box)        path.append(newPoint)    path.append(destination_point)    return path, boxes.keys()def checkPointInBox(point, box):    # point is defined as (y,x) for some reason    # Box is defined as (y1, y2, x1, x2) even though the instructions say it is the other way    if box[0] <= point[0] <= box[1] and box[2] <= point[1] <= box[3]:        return True    return False# Implemented for the second step in the suggested workflow. Not used anymoredef bfsBox(source_point, destination_point, mesh):    # This code is based on the bfs code from redblobgames.com    frontier = Queue()    frontier.put(source_point)    came_from = dict()    came_from[source_point] = None    # do the actual search    while not frontier.empty():        current = frontier.get()        for next in mesh["adj"][current]:            if next not in came_from:                frontier.put(next)                came_from[next] = current    # and now get the path from that    current = destination_point    path = []    while current != source_point:        path.append(current)        current = came_from[current]    path.append(source_point)    path.reverse()    print("path found!", path)    return path# I had some help from chatGPT when trying to figure out the final clamping for the x and y pointsdef getPathBetweenBoxes(initPoint, box1, box2):    # Calculate intersection bounds    intersect_min_x = max(box1[2], box2[2])    intersect_max_x = min(box1[3], box2[3])    intersect_min_y = max(box1[0], box2[0])    intersect_max_y = min(box1[1], box2[1])    # Clamp point to intersection bounds    clamped_x = max(intersect_min_x, min(initPoint[1], intersect_max_x))    clamped_y = max(intersect_min_y, min(initPoint[0], intersect_max_y))    return clamped_y, clamped_xdef calculateEuclideanDistance(point1, point2):    # We are in cartesian coordinates, so we can use the pythagorean theorem    return math.sqrt(pow((point1[0] - point2[0]), 2) + pow((point1[1] - point2[1]), 2))# Begin A* stuff# We are gonna need to track the points and boxes because the points could be closer to one side of a box than another. yayayyyyydef dijkstraAlg(startingPoint, destinationPoint, startingBox, endingBox, grid):    paths = {startingBox: []}    pathCosts = {startingBox: 0}    queue = []    heappush(queue, (0, (startingBox, startingPoint)))    while queue:        priority, current = heappop(queue)        # Check to see if we have reached the destination        if current[0] == endingBox:            return pathToBox(current, paths)        # If not, check the children of the current box and see if we can get any closer to the destination        for child in grid["adj"][current[0]]:            cost, squarePoint = transitionCost(current, child, destinationPoint, endingBox)            costToChild = priority + cost            if child not in pathCosts or costToChild < pathCosts[child]:                pathCosts[child] = costToChild                paths[child] = current                heappush(queue, (costToChild, (child, squarePoint)))    return Falsedef pathToBox(box, paths):    if box == []:        return []    return pathToBox(paths[box[0]], paths) + [box[0]]def transitionCost(src, dest, destinationPoint, endingBox):    # We need to do some checking if this is the last box. Especially if its the massive box on the right    if dest == endingBox:        childPoint = destinationPoint    else:        childPoint = getPathBetweenBoxes(src[1], src[0], dest)    # src should already have its point, but we need to add the closest point to dest and then see how far it would be    srcPoint = src[1]    # And now we can see just how long that path would be.    distance = math.sqrt(pow(srcPoint[0] - childPoint[0], 2) + pow(srcPoint[1] - childPoint[1], 2))    return (distance, childPoint)# End A* stuff