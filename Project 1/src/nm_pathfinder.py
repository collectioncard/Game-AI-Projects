import mathfrom heapq import heappush, heappopdef find_path(source_point, destination_point, mesh):    """        Searches for a path from source_point to destination_point through the mesh        Args:            source_point: starting point of the pathfinder            destination_point: the ultimate goal the pathfinder must reach            mesh: pathway constraints the path adheres to        Returns:            A path (list of points) from source_point to destination_point if exists            A list of boxes explored by the algorithm        """    path = []    boxes = {}    # Keep track of the starting and ending boxes    starting_box = None    ending_box = None    # keep track of point history    boxLocationHistory = dict()    # Step 1: Find the boxes that we start and end in    for box in mesh["boxes"]:        # Check the starting point        if checkPointInBox(source_point, box):            starting_box = box            boxLocationHistory[box] = source_point        # Check the ending point        if checkPointInBox(destination_point, box):            ending_box = box            boxLocationHistory[box] = destination_point    # Step 2: pathfind between those boxes    if starting_box is not None and ending_box is not None:        foundPath = biDirectionalAStar(boxLocationHistory, starting_box, ending_box, mesh)        if foundPath is False:            print("No path Possible!")            return path, boxes.keys()        for box in foundPath:            boxes[box] = "path"    else:        print("No path possible!")        return path, boxes.keys()    # Step 3: draw a path    for index, box in enumerate(boxes.keys()):        # Deal with the start point        if box == starting_box:            path.append(source_point)            continue        # Now calculate stuff - box is the next box and the last can be found with foundPath[i-1]        newPoint = getPathBetweenBoxes(path[index - 1], foundPath[index - 1], box)        path.append(newPoint)    path.append(destination_point)    return path, boxes.keys()def biDirectionalAStar(boxLocationHistory, startingBox, endingBox, grid):    frontier = []    heappush(frontier, (0, startingBox, "forward"))    heappush(frontier, (0, endingBox, "backward"))    cameFromForward = {}    cameFromBackward = {}    costForward = {}    costBackward = {}    # Easy way to keep track of nodes that we have already visited. Idk, I'm lazy    visitedForward = set()    visitedBackward = set()    # Init the starting and ending boxes    cameFromForward[startingBox] = None    cameFromBackward[endingBox] = None    costForward[startingBox] = 0    costBackward[endingBox] = 0    while frontier:        currentPriority, currentBox, currentDirection = heappop(frontier)        if currentDirection == "forward":            visitedForward.add(currentBox)            # Check to see if we have found the other half of the alg            if currentBox in visitedBackward:                break            for next in grid["adj"][currentBox]:                newCost = costForward[currentBox] + calculateTraversalCost(currentBox, next, boxLocationHistory,                                                                           endingBox)                if next not in costForward or newCost < costForward[next]:                    costForward[next] = newCost                    priority = newCost + calculateDistance(boxLocationHistory[next], boxLocationHistory[endingBox])                    heappush(frontier, (priority, next, "forward"))                    cameFromForward[next] = currentBox        elif currentDirection == "backward":  # Same as before, just backwards and the distance to the starting box            visitedBackward.add(currentBox)            if currentBox in visitedForward:                break            for next in grid["adj"][currentBox]:                newCost = costBackward[currentBox] + calculateTraversalCost(currentBox, next, boxLocationHistory,                                                                            startingBox)                if next not in costBackward or newCost < costBackward[next]:                    costBackward[next] = newCost                    priority = newCost + calculateDistance(boxLocationHistory[next], boxLocationHistory[startingBox])                    heappush(frontier, (priority, next, "backward"))                    cameFromBackward[next] = currentBox    # Now hopefully we have something. Check all the points and see if any match    centerPoint = None    for point in visitedForward:        if point in visitedBackward:            centerPoint = point            break    if centerPoint is None:        return False    # Now construct the path for both    # Chat GPT helped me figure out a way to combine the paths because I was stuck on this for a long time    # https://chatgpt.com/share/defc307f-6990-4a9f-a45d-720bb9d3cc71    path_forward = []    currentBox = centerPoint    while currentBox is not None:        path_forward.append(currentBox)        currentBox = cameFromForward.get(currentBox, None)    path_forward.reverse()    path_backward = []    currentBox = centerPoint    while currentBox is not None:        path_backward.append(currentBox)        currentBox = cameFromBackward.get(currentBox, None)    # Remove the meeting point to avoid duplicating in the final path    path_backward.pop(0)    return path_forward + path_backwarddef calculateTraversalCost(startBox, destBox, pointLibrary, finalBox):    if destBox == finalBox:        return calculateDistance(pointLibrary[startBox], pointLibrary[finalBox])    if destBox not in pointLibrary:        pointLibrary[destBox] = getPathBetweenBoxes(pointLibrary[startBox], startBox, destBox)    return calculateDistance(pointLibrary[startBox], pointLibrary[destBox])def calculateDistance(point1, point2):    return math.sqrt(pow((point1[0] - point2[0]), 2) + pow((point1[1] - point2[1]), 2))def getPathBetweenBoxes(currentPoint, box1, box2):    # Calculate intersection bounds    intersect_min_x = max(box1[2], box2[2])    intersect_max_x = min(box1[3], box2[3])    intersect_min_y = max(box1[0], box2[0])    intersect_max_y = min(box1[1], box2[1])    # Clamp point to intersection bounds - Chat GPT helped me figure out the final clamping required for this    # https://chatgpt.com/share/5f263dd7-136e-4241-a930-3e7030a1600e    clamped_x = max(intersect_min_x, min(currentPoint[1], intersect_max_x))    clamped_y = max(intersect_min_y, min(currentPoint[0], intersect_max_y))    return clamped_y, clamped_xdef checkPointInBox(point, box):    # point is defined as (y,x) for some reason    # Box is defined as (y1, y2, x1, x2) even though the instructions say it is the other way    if box[0] <= point[0] <= box[1] and box[2] <= point[1] <= box[3]:        return True    return False