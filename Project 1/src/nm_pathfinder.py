from queue import Queuedef find_path(source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    print("test")    # TODO: track of these better    starting_box = None    ending_box = None    # Step 1: Find the boxes that we start and end in    for box in mesh["boxes"]:        # Check the starting point        if checkPointInBox(source_point, box):            starting_box = box        # Check the ending point        if checkPointInBox(destination_point, box):            ending_box = box    print("path", path)    print(boxes)    # step 2: pathfind between those boxes    if starting_box is not None and ending_box is not None:        path = bfsBox(starting_box, ending_box, mesh)        for box in path:            boxes[box] = "path"    else:        print("No path possible!")        return path, boxes.keys()    # Step 3: draw a path    return path, boxes.keys()def checkPointInBox(point, box):    # point is defined as (y,x) for some reason    # Box is defined as (y1, y2, x1, x2) even though the instructions say it is the other way    if box[0] <= point[0] <= box[1] and box[2] <= point[1] <= box[3]:        print("point", point, "in box", box)        return True    return Falsedef bfsBox(source_point, destination_point, mesh):    # This code is based on the bfs code from redblobgames.com    frontier = Queue()    frontier.put(source_point)    came_from = dict()    came_from[source_point] = None    # do the actual search    while not frontier.empty():        current = frontier.get()        for next in mesh["adj"][current]:            if next not in came_from:                frontier.put(next)                came_from[next] = current    # and now get the path from that    current = destination_point    path = []    while current != source_point:        path.append(current)        current = came_from[current]    path.append(source_point)    path.reverse()    print("path found!", path)    return path